# time

- [time](#time)
  - [delay()](#delay)
    - [delay()의 단점](#delay의-단점)
  - [timer](#timer)
    - [timer의 장점](#timer의-장점)
    - [timer 단점](#timer-단점)
    - [millis()](#millis)
      - [millis()의 장점](#millis의-장점)
      - [millis()의 단점](#millis의-단점)
  - [결론](#결론)

## delay()
특정 시간 동안 코드 실행을 멈추는 방법(간단함)

```c
while (1)
{
//	  3초간격으로 Toggle되도록(PIN5, LD4)
    HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_5);
	HAL_Delay(3000);
}
```
위와 같이 HAL_Delay를 사용해서 시간을 조율한다면
> 여러 가지 문제가 생길 수 있다.

### delay()의 단점
1. **CPU 자원 소모**:

    HAL_Delay 함수는 내부적으로 `SysTick` 타이머를 사용하여 지연 시간을 구현한다. 이 함수는 지정된 시간 동안 현재 스레드를 블록하여 기다린다. 이 동안 MCU는 다른 작업을 수행할 수 없다. 즉, `CPU는 HAL_Delay가 완료될 때까지 다른 작업을 수행하지 못하고 대기 상태`가 된다.
    
2. **비효율적인 멀티태스킹**:

    MCU에서 HAL_Delay를 사용하는 경우, `여러 작업을 동시에 수행하거나 시간에 민감한 작업을 해야 하는 경우에는 비효율`적이다. 예를 들어, 다른 이벤트를 처리하거나 센서 데이터를 읽는 등의 작업을 해야 할 때 HAL_Delay는 해당 작업들이 실행될 수 없게 한다.

3. **정밀도 문제**:

    HAL_Delay는 주로 SysTick 타이머의 정확성을 기반으로 하지만, 때때로 이 함수는 정확한 시간 지연을 보장하지 않을 수 있다. 타이머의 오차나 시스템 클럭의 불안정성 등으로 인해 `지연 시간이 약간의 오차를 가질 수 있다`.

4. **지속적 지연**:

    HAL_Delay는 지연 시간이 끝날 때까지 CPU를 블록한다. 따라서 `지연 시간 동안 MCU가 다른 작업을 처리할 수 없으며, 이로 인해 시스템 응답성이 저하`될 수 있다.

> 즉 `HAL_Delay`사용 시 `멀티태스킹 불가`하고, `자원이 소모`되며, `비정밀한`특성을 가지게 되어 `응답성이 저하`될 수 있다. 

그렇다면 어떻게 시간을 관리해야 할까?

## timer
> HW적으로 시간을 측정하고, 특정 시간 간격이 지나면 인터럽트를 발생시키는 기능

타이머의 사용으로 아래의 이점을 얻을 수 있다.

### timer의 장점
1. 멀티태스킹 가능(`비동기`적 동작)
2. `정밀`한 시간 제어
3. 시스템 전체의 `효율성과 응답성` 높일 수 있음

### timer 단점
delay()에 비해 비교적 복잡함

---
### millis()
millis() 함수는 타이머 기반으로 `시스템이 켜진 이후로 경과된 밀리초를 반환`한다. 이 함수는 delay() 함수와 달리 CPU를 블록하지 않으며, 타이머를 사용해 `비동기적으로 시간 경과를 측정`한다.

#### millis()의 장점
1. **비동기 작업 처리**: 

   millis()를 사용하면 다른 작업을 동시에 수행하면서 시간 경과를 추적할 수 있다.

2. **CPU 자원 절약**: 
   
   millis()는 `비동기적으로 작동`하므로 CPU가 다른 작업을 수행하면서 시간 경과를 추적할 수 있다. delay()보다 훨씬 `효율`적이다.

3. **정밀한 시간 제어**: 

   millis()는 시스템 타이머를 기반으로 동작하며, 일반적으로 `정밀한 시간 측정`을 가능하게 한다. 그러나 시스템 클럭의 정확성에 따라 오차가 있을 수 있다.

#### millis()의 단점
1. **범위 제한**: 

   millis()는 반환하는 값의 범위가 제한되어 있다. 보통 32비트 정수로 구현되어 있으며, 약 50일 후에 `오버플로우가 발생할 수 있다`. 오버플로우를 고려하여 설계를 해야 한다.

2. **정확성**: 

    millis() 함수는 `타이머의 정확성에 의존`하며, 클럭 주파수의 불안정성이나 타이머 설정에 따라 약간의 오차가 발생할 수 있다.

## 결론
`HAL_Delay()` 함수는 간단하게 지연을 구현할 수 있지만, 멀티태스킹을 방해하고 CPU 자원을 낭비할 수 있다.

`타이머`를 사용하는 방법은 비동기적으로 작업을 처리할 수 있어 시스템의 효율성과 응답성을 높일 수 있다. 그러나 구현이 복잡할 수 있다.

`millis()` 함수는 타이머 기반으로 비동기적으로 시간 경과를 측정하며, 효율적이고 정밀하게 시간을 관리할 수 있다. 다만, 오버플로우와 정확성 문제를 염두에 두어야 한다.